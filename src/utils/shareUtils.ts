import pako from 'pako';

/**
 * Result of data URL generation
 */
export interface DataUrlResult {
  success: boolean;
  url?: string;
  error?: string;
  tooLarge?: boolean;  // URL > 100K characters
  warningSize?: boolean;  // URL > 50K characters
}

/**
 * Result of GitHub Gist creation
 */
export interface GistResult {
  success: boolean;
  url?: string;
  error?: string;
  errorType?: 'rate_limit' | 'network' | 'api_error';
  rateLimitReset?: Date;
  rateLimitRemaining?: number;
}

/**
 * Result of Web Share API operation
 */
export interface WebShareResult {
  success: boolean;
  error?: string;
  cancelled?: boolean;
}

/**
 * Compress HTML and generate shareable data URL
 */
export async function createDataUrl(html: string): Promise<DataUrlResult> {
  try {
    // 1. Compress with pako
    const compressed = pako.deflate(html);

    // 2. Convert to base64
    const base64 = btoa(String.fromCharCode(...compressed));

    // 3. Convert to base64url (URL-safe: replace + with - and / with _)
    const base64url = base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');

    // 4. Create URL
    const url = `${window.location.origin}?p=${base64url}`;

    // 5. Check length
    const tooLarge = url.length > 100000;  // 100K
    const warningSize = url.length > 50000;  // 50K

    return {
      success: true,
      url,
      tooLarge,
      warningSize
    };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Compression failed'
    };
  }
}

/**
 * Decompress data URL parameter back to HTML
 */
export function parseDataUrl(compressed: string): string {
  try {
    // Convert base64url back to base64 (reverse URL-safe encoding)
    let base64 = compressed.replace(/-/g, '+').replace(/_/g, '/');

    // Add back padding if needed
    while (base64.length % 4) {
      base64 += '=';
    }

    // Decode base64
    const decoded = atob(base64);

    // Convert to byte array
    const bytes = Uint8Array.from(decoded, c => c.charCodeAt(0));

    // Decompress with pako
    const html = pako.inflate(bytes, { to: 'string' });

    return html;
  } catch (error) {
    console.error('parseDataUrl error details:', {
      compressedLength: compressed.length,
      error: error instanceof Error ? error.message : 'Unknown error',
      firstChars: compressed.substring(0, 20),
      lastChars: compressed.substring(compressed.length - 20)
    });
    throw new Error(`Failed to parse data URL: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

/**
 * Create anonymous GitHub Gist
 */
export async function createGithubGist(
  html: string,
  fileName: string = 'year-in-review.html'
): Promise<GistResult> {
  try {
    const response = await fetch('https://api.github.com/gists', {
      method: 'POST',
      headers: {
        'Accept': 'application/vnd.github+json',
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        public: true,
        description: 'Year in Review - Generated by yirgachefe.lol',
        files: {
          [fileName]: {
            content: html
          }
        }
      })
    });

    // Check rate limit headers
    const remaining = response.headers.get('X-RateLimit-Remaining');
    const reset = response.headers.get('X-RateLimit-Reset');

    if (response.status === 403) {
      // Rate limited
      const resetDate = reset ? new Date(parseInt(reset) * 1000) : undefined;
      return {
        success: false,
        errorType: 'rate_limit',
        rateLimitReset: resetDate,
        rateLimitRemaining: 0,
        error: 'Rate limit exceeded'
      };
    }

    if (!response.ok) {
      return {
        success: false,
        errorType: 'api_error',
        error: `GitHub API error: ${response.status}`
      };
    }

    const data = await response.json();

    return {
      success: true,
      url: data.html_url,
      rateLimitRemaining: remaining ? parseInt(remaining) : undefined
    };

  } catch (error) {
    return {
      success: false,
      errorType: 'network',
      error: error instanceof Error ? error.message : 'Network error'
    };
  }
}

/**
 * Check if Web Share API is available
 */
export function canUseWebShare(): boolean {
  return 'share' in navigator && 'canShare' in navigator;
}

/**
 * Share presentation using Web Share API
 */
export async function shareWithWebApi(
  screenshot: Blob,
  title: string,
  text: string
): Promise<WebShareResult> {
  if (!canUseWebShare()) {
    return {
      success: false,
      error: 'Web Share API not supported'
    };
  }

  try {
    const file = new File([screenshot], 'year-in-review.png', { type: 'image/png' });

    // Check if we can share this data
    if (!navigator.canShare({ files: [file] })) {
      return {
        success: false,
        error: 'Cannot share files'
      };
    }

    await navigator.share({
      title,
      text,
      files: [file]
    });

    return { success: true };

  } catch (error) {
    // User cancelled
    if (error instanceof Error && error.name === 'AbortError') {
      return {
        success: false,
        cancelled: true
      };
    }

    return {
      success: false,
      error: error instanceof Error ? error.message : 'Share failed'
    };
  }
}

/**
 * Copy text to clipboard
 */
export async function copyToClipboard(text: string): Promise<boolean> {
  try {
    if (navigator.clipboard) {
      await navigator.clipboard.writeText(text);
      return true;
    }

    // Fallback for older browsers
    const textarea = document.createElement('textarea');
    textarea.value = text;
    textarea.style.position = 'fixed';
    textarea.style.opacity = '0';
    document.body.appendChild(textarea);
    textarea.select();
    const success = document.execCommand('copy');
    document.body.removeChild(textarea);
    return success;

  } catch (error) {
    console.error('Copy failed:', error);
    return false;
  }
}
